{"categories":[{"title":"JavaScript","uri":"https://allen-yangjh.github.io/categories/javascript/"},{"title":"随笔","uri":"https://allen-yangjh.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"posts":[{"content":"localStorage、sessionStorage、Cookie的用法及区别。\nwebstorage webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage。\n1. localStorage 方法存储的数据没有时间限制。\n第二天、第二周或下一年之后，数据依然可用。\n2. sessionStorage 方法针对一个 session 进行数据存储。\n当用户关闭浏览器窗口后，数据会被删除。\n 键值对总是以字符串的形式存储\nlocalStorage和sessionStorage使用时使用相同的API：\n 存储数据：\nsessionStorage.setItem('key', 'str'); localStorage.setItem('key', 'str');  获取数据：\nsessionStorage.getItem('key'); localStorage.getItem('key');  删除某个数据：\nsessionStorage.removeItem('key'); localStorage.removeItem('key');  删除所有数据：\nsessionStorage.clear(); localStorage.clear();   localStorage 与 sessionStorage的比较  作用域不同  不同的浏览器无法共享localStorage或sessionStorage中的信息。 相同浏览器的不同页面之间（页面属于相同域名和端口）可以共享相同的 localStorage，但是不同页面或标签页间无法共享 sessionStorage 的信息。   3. Cookie 生命期为在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。\n存放数据大小为4K左右。有个数限制（各浏览器不同），一般不能超过20个。\n与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题。\n cookie的优点：具有极高的扩展性和可用性\n 通过良好的编程，控制保存在cookie中的session对象的大小。 通过加密和安全传输技术，减少cookie被破解的可能性。 只有在cookie中存放不敏感的数据，即使被盗取也不会有很大的损失。 控制cookie的生命期，使之不会永远有效。这样的话偷盗者很可能拿到的就 是一个过期的cookie。  cookie的缺点：\n cookie的长度和数量的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB。否则会被截掉。 安全性问题。如果cookie被人拦掉了，那个人就可以获取到所有session信息。加密的话也不起什么作用。 有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务端保存一个计数器。若吧计数器保存在客户端，则起不到什么作用。   localStorage、sessionStorage、Cookie共同点：都是保存在浏览器端，且同源的。","id":0,"section":"posts","summary":"\u003cp\u003elocalStorage、sessionStorage、Cookie的用法及区别。\u003c/p\u003e","tags":[],"title":"HTML 5 Web 本地存储","uri":"https://allen-yangjh.github.io/2019/12/blog02/","year":"2019"},{"content":"主要用于记录自己在项目工作和平时学习的过程中所碰到的Bug或疑难问题，方便回过头来查看复习。\n不断更新\u0026hellip;\n 微信ios/Safari中的new Date()格式化坑\nvar startTime = new Date('2017-03-08 00:00:00'); // 在ios中不兼容 返回valid Date // 将日其中的 - 替换成 /，兼容ios和Android var startTime2 = new Date('2017/03/08 00:00:00');  JQuery中Dom元素的data()用法\n 附加数据：\n// 附加单个数据 $(selector).data(key, value); // 附加多个数据 $(selector).data({key1: value, key2: value});  取回数据：\n// 取出指定数据 $(selector).data(key); // val // 取出所有数据 $(selector).data(); // obj  移除数据：\n// 移除指定数据 $(selector).removeData(key); // 移除多个数据 $(selector).removeData([key1, key2]);   JQuery中 attr() 与 prop() 的区别\nattr 与 prop 从中文意思看，两者分别是获取/设置 attributes 和 properties 的方法。\n什么时候使用attr()，什么时候使用prop()？\n官方的建议：具有 true 和 false 两个属性的属性，如 checked, selected 或者 disabled 时使用 prop()，其他的使用 attr()。\n CSS Position详解：\n position: static\n是默认布局，设置top、left属性不会有作用。 position: relative\n不会脱离文档流；\n相对于自己在文档流中的初始位置偏移定位。 position: fixed\n会脱离文档流；\n相对于浏览器窗口定位。 position: absolute\n会脱离文档流。\n是相对于父级 非position:static 浏览器定位。\n如果没有任何一个父级元素是 非position:static 属性，则会相对于文档定位。\n这里它的父级元素是包含爷爷级元素、祖爷爷级元素、祖宗十八代级元素的。任意一级都可以。\n如果它的父级元素和爷爷级元素都是非position:static 属性，则，它会选择距离最近的父元素。  IDEA中 subversion 的使用说明\n参考：https://blog.csdn.net/qq_27093465/article/details/74898489\n JS中 substr() 和 substring() 的区别\n\tstring.substring(from, to); // from：指要截取的子串第一个字符在原字符串中的位置 // to：指所要截取的子字符串最后一个字符的后一位（如果省略则默认截到最后一位） string.substr(start, length); // start：指截取子串开始下标 // length：指截取子串的长度（如果省略则默认截到最后一位）  JS中 if 条件为 null/undefined/NaN/0/\u0026ldquo;\u0026rdquo; 表达式时，均为false\n官方解释： Boolean 表达式\n一个值为 true 或者 false 的表达式。如果需要，非 Boolean 表达式也可以被转换为 Boolean 值，但是要遵循下列规则：\n 所有的对象都被当作 true。 当且仅当字符串为空时，该字符串被当作 false。 null 和 undefined 被当作 false。 当且仅当数字为零时，该数字被当作 false。  JQ中 children() 和 find() 方法的区别：\n children() 只获取匹配当前元素的下一级元素； find() 可获取匹配当前元素的整个树级元素；  Windows下查看IIS中站点对应的进程PID，以用来方便进程调试\n 管理员身份运行cmd，跳转到C:\\Windows\\System32\\inetsrv目录，然后运行appcmd list wp即可查看  Aspose实现Office转PDF (ASP.NET)\n参考 https://www.cnblogs.com/moonache/p/4991459.html\n其他方法Microsoft.Office https://www.cnblogs.com/yunfeifei/p/4520414.html\n C#中 webservice 请求响应时间设置\n a.服务端webconfig中\n\u0026lt; httpRuntime executionTimeout=\u0026ldquo;300\u0026rdquo; /\u0026gt; \u0026lt; compilation debug=\u0026ldquo;false\u0026rdquo; /\u0026gt; b.客户端调用时 加上\nHttpWebRequest wr = (HttpWebRequest)base.GetWebRequest( uri ); wr.Timeout = 300*1000;  参考： https://blog.csdn.net/wygyhm/article/details/2819388\n ","id":1,"section":"posts","summary":"\u003cp\u003e主要用于记录自己在项目工作和平时学习的过程中所碰到的Bug或疑难问题，方便回过头来查看复习。\u003cbr /\u003e\n\u003cem\u003e不断更新\u0026hellip;\u003c/em\u003e\u003c/p\u003e","tags":["JavaScript","CSS","C#"],"title":"随笔01","uri":"https://allen-yangjh.github.io/2019/12/essay01/","year":"2019"},{"content":"结合实际例子与使用方式介绍Array对象的方法。\nJS中 Array 对象的方法使用详解: 1.常用的基本方法  concat() (合并数组)连接两个或个多的数组，并返回结果。传入的可以是具体值、也可以是数组对象。 该方法不改变原数组\nlet arr1 = [1, 2, 3]; let arr2 = [4, 5]; arr1.concat(arr2, 6); // [1, 2, 3, 4, 5, 6]  join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔，如果省略该参数，则默认使用逗号作为分隔符。\nlet arr = [1, 2, 3]; arr.join('|'); // \u0026quot;1|2|3\u0026quot;  pop() 删除并返回数组的最后一个元素，把数组长度减 1。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。\nlet arr = [1, 2, 3]; arr.pop(); // 3  push() 向数组的末尾添加一个或多个元素，返回新的长度。\npush() 方法和 pop() 方法使用数组提供的先进后出栈的功能。\nlet arr = [\u0026quot;Bob\u0026quot;, \u0026quot;John\u0026quot;]; arr.push(\u0026quot;James\u0026quot;); // 3 console.log(arr); // [\u0026quot;Bob\u0026quot;, \u0026quot;John\u0026quot;, \u0026quot;James\u0026quot;]  shift() 删除并返回数组的第一个元素。将已经存在的元素顺次往前移。\nlet arr = [1, 2, 3]; arr.shift(); // 1  unshift() 向数组的开头添加一个或多个元素，返回新的长度。将参数插入数组的头部，将已经存在的元素顺次往后移。\nunshift() 方法无法在 Internet Explorer 中正确地工作！\nlet arr = [\u0026quot;Bob\u0026quot;, \u0026quot;John\u0026quot;]; arr.unshift(\u0026quot;James\u0026quot;); // 3 console.log(arr); // [\u0026quot;James\u0026quot;, \u0026quot;Bob\u0026quot;, \u0026quot;John\u0026quot;]  reverse() 颠倒数组中元素的顺序。\n不常用\n slice() (裁剪数组)根据下标返回数组中选定的元素。包含start和end两个参数，可以为负数(从数组尾部开始算起)。如果 end 未被规定，会选取从 start 到数组结尾的所有元素。\nlet arr = [\u0026quot;George\u0026quot;, \u0026quot;John\u0026quot;, \u0026quot;Thomas\u0026quot;, \u0026quot;James\u0026quot;, \u0026quot;Adrew\u0026quot;]; arr.slice(2); // [\u0026quot;Thomas\u0026quot;, \u0026quot;James\u0026quot;, \u0026quot;Adrew\u0026quot;] arr.slice(2, 4); // [\u0026quot;Thomas\u0026quot;, \u0026quot;James\u0026quot;]  splice() (拼接数组)向数组指定位置删除或添加元素，返回被删除项目的新数组。删除的元素个数可以跟替换的元素个数不相等。\nlet arr = [\u0026quot;Bob\u0026quot;, \u0026quot;John\u0026quot;, \u0026quot;James\u0026quot;]; // 1.添加1个元素 arr.splice(1, 0, \u0026quot;William\u0026quot;); // [] 如果没有删除元素则返回空 console.log(arr); // [\u0026quot;Bob\u0026quot;, \u0026quot;William\u0026quot;, \u0026quot;John\u0026quot;, \u0026quot;James\u0026quot;] // 2.删除1个元素 arr = [\u0026quot;Bob\u0026quot;, \u0026quot;John\u0026quot;, \u0026quot;James\u0026quot;]; arr.splice(1, 1); // [\u0026quot;John\u0026quot;] console.log(arr); // [\u0026quot;Bob\u0026quot;, \u0026quot;James\u0026quot;] // 3.删除2个元素 添加1个元素来替换 arr = [\u0026quot;Bob\u0026quot;, \u0026quot;John\u0026quot;, \u0026quot;James\u0026quot;]; arr.splice(1, 2, \u0026quot;William\u0026quot;); // [\u0026quot;John\u0026quot;, \u0026quot;James\u0026quot;] console.log(arr); // [\u0026quot;Bob\u0026quot;, \u0026quot;William\u0026quot;]  sort() 对数组的元素进行排序。传入的必须是函数，如果没有传入参数，将按照内置算法对元素进行排序。 该方法在原数组上进行排序\n[内置算法]: JS中sort实现的算法是O(n^2)的冒泡排序，并会将每一项通过toString()转型，即将每一项转化为ASCII进行比较。\n如果想按照其他标准进行排序，就需要提供比较函数，该函数应该具有两个参数 a 和 b，其返回值如下：\n  若 a 小于 b，则返回一个小于0的值。在排序后的数组中 a 将出现在 b 之前 若 a 等于 b，则返回0。 若 a 大于 b，则返回一个大于0的值。\n   let arr = [10, 5, 40, 25, 100, 1]; // 内置算法会将数组中的每一项转化为ASCII进行比较，所以排序顺序有误。 arr.sort(); // [1, 10, 25, 40, 5] // 常见的比较函数有： // 1.按照数值大小升序排序 arr.sort(function(a,b){ return a - b; })； // [1, 5, 10, 25, 40, 100] // 2.按照数值大小降序排序 arr.sort(function(a,b){ return b - a; }); // [100, 40, 25, 10, 5, 1] // 3.按照对象的某一属性值排序 arr = [ {name: \u0026quot;Bob\u0026quot;, age: 13}, {name: \u0026quot;John\u0026quot;, age: 22}, {name: \u0026quot;James\u0026quot;, age: 7} ]; arr.sort(function(a, b){ var value1 = a.age; var value2 = b.age; return value1 - value2; }); // 4.打乱数组 arr.sort(function(a,b){ return Math.random() - 0.5; })  toString() 把数组转换为(逗号分隔的)字符串。返回值与没有参数的 join() 方法返回的字符串相同。\nlet arr = [1, 2, 3]; arr.toString(); // \u0026quot;1, 2, 3\u0026quot;   2.迭代方法  every() 用于检测数组所有元素是否都符合某个指定函数的条件。 该方法不改变原始数组\n若使用空数组，此方法在一切情况下都返回 true。\n every() 方法使用指定函数检测数组中的所有元素：\n 该函数接收3个参数，当前值_currentVal(必须)，当前值索引_index(可选)，当前数组_array(可选)。 如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。 如果所有元素都满足条件，则返回 true。   // 检测数组所有元素是否都大于10 function compare(val){ return val \u0026gt; 10; } let arr1 = [1, 11, 2, 22]; let arr2 = [20, 30, 40, 50]; arr1.every(compare); // false arr2.every(compare); // true  some() 用于检测数组所有元素是否至少有1项符合某个指定函数的条件。 该方法不改变原始数组\n若使用空数组，此方法在一切情况下都返回 false。\n some() 方法使用指定函数检测数组中的所有元素：\n 该函数接收3个参数，当前值_currentVal(必须)，当前值索引_index(可选)，当前数组_array(可选)。 如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。 如果没有满足条件的元素，则返回false。   // 检测数组是否有元素大于10 function compare(val){ return val \u0026gt; 10; } let arr1 = [1, 11, 2, 22]; let arr2 = [2, 3, 4, 5]; arr1.some(compare); // true arr2.some(compare); // false  filter() (过滤)用于找出数组中所有符合某个指定函数条件的元素、组成新的数组，并返回过滤后的新数组。 该方法不改变原始数组\n filter() 方法循环数组中的所有元素调用指定函数进行过滤：\n 该函数接收3个参数，当前值_currentVal(必须)，当前值索引_index(可选)，当前数组_array(可选)。\n 如果没有任何满足条件的元素，则返回空数组。   // 找出大于10的元素 function compare(val){ return val \u0026gt; 10; } let arr1 = [1, 11, 2, 22]; let arr2 = [2, 3, 4, 5]; arr1.filter(compare); // [11, 22] arr2.filter(compare); // []  forEach() (循环)用于对数组中的每个元素调用一次某个指定函数，没有返回值。\n除了抛出异常以外，没有办法中止或跳出 forEach() 循环。\n forEach() 方法接收一个指定函数：\n 该函数接收3个参数，当前值_currentVal(必须)，当前值索引_index(可选)，当前数组_array(可选)。\n   let arr = [1, 2, 3]; arr.forEach(function(item, index, arr){ arr[index] = val + 1; }); console.log(arr); // [2, 3, 4]  map() 将数组中的每一项调用某个指定函数后返回的结果组成新的数组，并返回该数组。 该方法不改变原始数组\n map() 方法接收一个指定函数：\n 该函数接收3个参数，当前值_currentVal(必须)，当前值索引_index(可选)，当前数组_array(可选)。   // 将数组中每一项乘以2 let arr = [1, 2 ,3]; arr.map(function(item){ return item * 2; }); console.log(arr); // [2, 4, 6]  reduce() 将数组中的每个元素调用某个指定的reducer函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。 该方法不改变原始数组\n reduce() 方法接收1个reducer函数和1个initialValue_初始值:\n reducer函数接收4个参数，累计器_accumulator(必须)，当前值_currentVal(必须)，当前值索引_index(可选)，当前数组_array(可选)。 如果没有提供初始值，则起始索引号为1，否则从索引0起始。 如果数组为空且没有提供初始值，调用reduce将报错。   // 累加方法 function add(prev, cur){ return prev + cur; }; // 未传入初始值 [0, 1, 2, 3, 4].reduce(add); // 10 // 传入初始值 [0, 1, 2, 3, 4].reduce(add, 5); // 15 // 注意点： // 1.如果数组仅有一个元素（无论位置如何）并且没有提供初始值，那么此唯一值将被返回并且callback不会被执行。 [ , 10].reduce(add); // 10 // 2.如果有提供初始值但是数组为空，那么此唯一值将被返回并且callback不会被执行。 [].reduce(add, 11); // 11 // 3.如果数组为空且没有提供初始值，会抛出TypeError 。 [].reduce(add); // TypeError // 例子：计算数组中每个元素出现的次数 var names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice']; var countedNames = names.reduce(function (allNames, name) { if (name in allNames) { allNames[name]++; } else { allNames[name] = 1; } return allNames; }, {}); console.log(countedNames); // { 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 }  reduceRight() 该方法的功能和 reduce() 功能是一样的，不同的是 reduceRight() 从数组的末尾向前循环每一项。\n//reduce 与 reduceRight 之间的区别 function add(prev, cur) { return prev + cur; } let arr = ['1', '2', '3', '4', '5']; let left = arr.reduce(add); let right = arr.reduceRight(add); console.log(left); // \u0026quot;12345\u0026quot; console.log(right); // \u0026quot;54321\u0026quot;   参考资料：  https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array https://www.runoob.com/jsref/jsref-obj-array.html ","id":2,"section":"posts","summary":"\u003cp\u003e结合实际例子与使用方式介绍Array对象的方法。\u003c/p\u003e","tags":["JavaScript"],"title":"JavaScript Array 对象","uri":"https://allen-yangjh.github.io/2019/12/blog01/","year":"2019"}],"tags":[{"title":"C#","uri":"https://allen-yangjh.github.io/tags/c#/"},{"title":"CSS","uri":"https://allen-yangjh.github.io/tags/css/"},{"title":"JavaScript","uri":"https://allen-yangjh.github.io/tags/javascript/"}]}