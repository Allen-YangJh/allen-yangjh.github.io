{"categories":[{"title":"Java","uri":"https://allen-yangjh.github.io/categories/java/"},{"title":"JavaScript","uri":"https://allen-yangjh.github.io/categories/javascript/"},{"title":"Java面试","uri":"https://allen-yangjh.github.io/categories/java%E9%9D%A2%E8%AF%95/"},{"title":"随笔","uri":"https://allen-yangjh.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"posts":[{"content":"经历了几次面试，把面试过程中所问到的技术问题记录下来。虽然不是什么大公司的技术面，也可以作为学习用，答案是我结合网上资料写的、仅供参考。\n最田电子商务公司  Redis中可存储什么类型的数据\n 字符串(String)、哈希(Map)、列表(list)、 集合(sets) 和有序集合(sorted sets)\n Session与Cookie的区别\n -\u0026nbsp;Cookie数据存放在客户端，不安全，浏览器禁用Cookie时无法使用。只能存储String类型的数据。\n-\u0026nbsp;Session数据存在在服务端，能够存储任意对象。\n Spring中的AOP原理？\n AOP，意为：面向切面编程。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。实现AOP技术主要分为两大类：动态代理技术和静态注入的方式。可用于权限认证、日志管理、事物处理等。\n 方法锁的概念\n 简单的例子：多人同时抢一张票。\n-\u0026nbsp;线程是否需要对资源加锁可以分为 悲观锁 和 乐观锁 \n-\u0026nbsp;资源已被锁定，线程是否阻塞可以分为 自旋锁 \n-\u0026nbsp;多个线程并发访问资源(Synchronized)，可以分为 无锁、偏向锁、轻量级 和 重量级锁 \n-\u0026nbsp;多个线程是否按照申请锁的顺序可以分为 公平锁 和 非公平锁 \n-\u0026nbsp;多个线程能否获取同一把锁可以分为 共享锁 和 独占锁 \n-\u0026nbsp;根据锁是否可重复获取可以分为 可重入锁 和 不可重入锁 \n final、finally、finalize的区别\n -\u0026nbsp;final：用于修饰属性、方法和类，分别表示属性不可变、方法不可被重写、类不可被继承\n-\u0026nbsp;finally：指异常处理语句(try……catch……finally)结构的一部分，表示总执行\n-\u0026nbsp;finalized：Object类中的一个方法，在垃圾回收器执行的时候调用被回收对象的此方法，更像一个对象生命周期的临终方法\n  见道科技有限公司  Redis和Mysql的区别。分别存储在什么位置\n -\u0026nbsp;MySQL是经典的关系型数据库，通过sql语句进行查询，数据存储在硬盘中。\n-\u0026nbsp;Redis是非关系型数据库，只能用key去获取value，数据保存在内存中、读取速度快。\n  跨界科技有限公司  mysql中多表查询性能优化\n mysql锁、高并发处理\n MySQL 不同的存储引擎支持不同的锁机制。\n-\u0026nbsp;表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。\n-\u0026nbsp;行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。\n-\u0026nbsp;页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。\n高并发请求时，可利用缓存。\n 权限框架、netty框架、sofa框架的了解\n 对Socket使用的理解(引用了什么包)\n  金彩水族有限公司  ==和equals的区别？equals实现值比较的原理\n -\u0026nbsp;==：如果比较的对象是基本数据类型，则比较的是数值是否相等；如果比较的是引用数据类型，则比较的是对象的地址值是否相等。\n-\u0026nbsp;equals()：用来比较方法两个对象的内容是否相等。注：：equals 方法不能用于基本数据类型的变量，如果没有对 equals 方法进行重写，则比较的是引用类型的变量所指向的对象的地址。\n-\u0026nbsp;equals() 属于Object类中的方法，默认上也是使用==来比较，实际上比较的是两个对象的内存地址。常用的数据类中都会重写equals()方法，比如String、Integer。\n 集合继承关系\n -\u0026nbsp;Collection\n\u0026nbsp;\u0026nbsp; -\u0026gt; List -\u0026gt; ArrayList/LinkedList/Vector\n\u0026nbsp;\u0026nbsp; -\u0026gt; Set -\u0026gt; HashSet/TreeSet/LinkedHashSet\n ArrayList和Linkedlist区别? linkedList如何去重\n -\u0026nbsp;ArrayList：底层结构是数组，底层查询快，增删慢。在内存中连续存储的。\n-\u0026nbsp;LinkedList：底层结构是链表型的，增删快，查询慢。动态申请内存空间。\n-\u0026nbsp;创建一个新的List，将原list中的每一项存入新list中，同时判断新list中是否已存在当前存入的值。\n-\u0026nbsp;利用HashSet的无重复性，先将linkedlist转换成hashset，再转回linkedlist。\n MySQL数据类型\n -\u0026nbsp;整数型：tinyint、smallint、mediumint、int、bigint\n-\u0026nbsp;小数型：float、double、decimal\n-\u0026nbsp;日期型：datetime、time、timestamp\n-\u0026nbsp;字符串型：char、varchar\n MySQL中索引的理解\n -\u0026nbsp;索引就是一个数据结构，把表中的记录用一个适合高效查找的数据结构来表示，目的就是让查询变得更高效。\n-\u0026nbsp;常见的有两种结构，Hash索引和B+ Tree索引，我们使用的是InnoDB引擎，默认的是B+树。\n AOP的动态代理怎么写\n Dao层中传入数组作为in的值、怎么写xml语句\n\u0026lt;foreach item=\u0026quot;item\u0026quot; index=\u0026quot;index\u0026quot; collection=\u0026quot;list\u0026quot; open=\u0026quot;(\u0026quot; separator=\u0026quot;,\u0026quot; close=\u0026quot;)\u0026quot;\u0026gt; #{item} \u0026lt;/foreach\u0026gt;  MyBatis缓存的理解\n -\u0026nbsp;一级缓存： 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session。\n-\u0026nbsp;二级缓存：，默认也是采用 PerpetualCache，HashMap存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源。\n-\u0026nbsp;首先查询二级缓存，再查询一级缓存\n Java中创建线程的方式\n -\u0026nbsp;通过继承Thread类并重写run()方法；\n-\u0026nbsp;使用匿名内部类，new一个Thread再传入Runnable的匿名类并重写run()方法；简单快捷\n-\u0026nbsp;实现Runnable接口；Runnable对象只是线程的target，作为参数传入Thread实现\n-\u0026nbsp;实现Callable接口，结合FutureTask实现；\n-\u0026nbsp;线程池newFixedThreadPool()\n-\u0026nbsp;定时器Timer\n  阀太师科技有限公司  String a = \u0026quot;123\u0026quot;; String b = \u0026quot;123\u0026quot;; String c = new String(\u0026quot;123\u0026quot;); String d = \u0026quot;12\u0026quot; + \u0026quot;3\u0026quot;; String e = \u0026quot;12\u0026quot;; String f = \u0026quot;3\u0026quot;; 用==比较，求结果。 - a==b; // true - a==c; // false - a==d; // true - a==e+\u0026quot;3\u0026quot;; // false - a==e+f; // false   -\u0026nbsp;String 直接赋值时 创建在常量池中，new String在堆内存中\n-\u0026nbsp;d是常量与常量拼接、结果存在于常量池中，所以a==d是true\n-\u0026nbsp;e(变量) + \u0026ldquo;3\u0026rdquo;(常量)的结果存在于堆里面，所以与a比较是false\n-\u0026nbsp;e本来是变量，final String e = \u0026ldquo;12\u0026rdquo;; 用final修饰后就变成了常量，同样e+\u0026ldquo;3\u0026rdquo;; 就变成了常量和常量拼接，结果存在于常量池。final改变不了new String()，结果仍然会在堆内存里。\n-\u0026nbsp;虽然e和f都在常量池中，但是他们拼接之后结果在堆内存里\n HashMap 和 HashTbale 的区别。对LinkedHashMap的认识\n -\u0026nbsp;HashMap：是线程不安全的，是将键映射到值得对象,不允许键值重复。允许有一个key为null，允许多个value为null；\n-\u0026nbsp;HashTable：是线程安全的，很多方法都有synchronized修饰。不允许key或者value为null。\n-\u0026nbsp;HashMap 的效率要较 HashTable 的效率高一些。\n-\u0026nbsp;LinkedHashMap：是 HashMap的一个子类，继承了HashMap的特性，额外加了双向链表的结构，保存了记录的插入顺序，更像是一个有序的HashMap。\n HashMap 的原理\n -\u0026nbsp;HashMap基于Map接口实现，元素以键值对的方式存储，并且允许key或者value为null，因为key不允许重复，因此只能有一个键为null。\n-\u0026nbsp;HashMap是线程不安全的。不能保证放入元素的顺序，它是无序的。\n-\u0026nbsp;HashMap的数据结构为 数组+(链表或红黑树)，(数组的特点：查询效率高，插入，删除效率低。链表的特点：查询效率低，插入删除效率高。)。在HashMap底层使用数组加（链表或红黑树）的结构完美的解决了数组和链表的问题，使得查询和插入，删除的效率都很高。\n-\u0026nbsp;HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体。\n 解释一下什么是 Servlet，说一说 Servlet 的生命周期。Jsp 和 Servlet 有什么区别？\n -\u0026nbsp;Servlet是一种服务器端的Java应用程序，可以生成动态的Web页面。\n-\u0026nbsp;Servlet生命周期可以分成四个阶段：加载和实例化、初始化、服务、销毁。\n-\u0026nbsp;Jsp：本质上就是一个Servlet，它是Servlet的一种特殊形式，每个jsp页面都是一个servlet实例。jsp是html页面中内嵌的Java代码，侧重页面显示\n-\u0026nbsp;Servlet：是html代码和Java代码分离，侧重逻辑控制。用于开发 web服务器应用程序的一个组件\n 常见的加密算法有哪些\n -\u0026nbsp;单向加密：Base64 / MD5 / SHA / HMAC\n-\u0026nbsp;对称加密：指消息收发都有相同的一把钥匙，消息的加密解密都用这把钥匙\n-\u0026nbsp;非对称加密：需要两个密钥：公开密钥和私有密钥 。 公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。\n MySQL语句笔试题（学生表_课程表_成绩表_教师表）\n参考链接：https://www.cnblogs.com/qixuejia/p/3637735.html\n  文思海辉外包蚂蚁金服  char c = new char[10] c[0] = ?; 空  int[] a = null; A. if (a == null \u0026amp; a.length == 0){}; B. if (a != null \u0026amp;\u0026amp; a.length == 0){}; C. if (a == null | a.length == 0){}; D. if (a == null || a.length == 0){}; 运行报错的是(A C)  class A { public int getNum(int a) { return a + 1; } } class B extends A { public int getNum(int a, char b) { return a + b; } } B b = new B(); b.getNum(1); 输出 2;  接口与抽象类的区别\n 两者都不能被实例化。\n-\u0026nbsp;抽象类：\n\u0026nbsp;1)\u0026nbsp;抽象类不能被实例化只能被继承、\n\u0026nbsp;2)\u0026nbsp;包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法、\n\u0026nbsp;3)\u0026nbsp;抽象类可以包含属性、方法、静态方法、构造方法，但是构造方法不能用于实例化，主要用途是被子类调用、\n\u0026nbsp;4)\u0026nbsp;一个子类继承一个抽象类，则子类必须实现父类抽象方法，否则子类也必须定义为抽象类\n-\u0026nbsp;接口：\n\u0026nbsp;1)\u0026nbsp;接口支持多继承，即一个接口可以extends多个接口、\n\u0026nbsp;2)\u0026nbsp;一个类可以实现多个接口、\n\u0026nbsp;3)\u0026nbsp;接口中不能定义构造函数、不能有静态方法，全部都是抽象方法。\n Nginx 如何使用到项目中\n ","id":0,"section":"posts","summary":"\u003cp\u003e经历了几次面试，把面试过程中所问到的技术问题记录下来。虽然不是什么大公司的技术面，也可以作为学习用，答案是我结合网上资料写的、仅供参考。\u003c/p\u003e","tags":["Java"],"title":"Java 面试技术问题整理（附答案）","uri":"https://allen-yangjh.github.io/2020/01/blog04/","year":"2020"},{"content":"今年年初的时候，从C#转到Java开发，跟着大佬做了半年的业务开发，但是对于基础掌握的太少、所以自学了一些基础知识。\n前言 一、Java语言发展  Java诞生于1995年，原名Oak，由Sun公司开发的面向对象编程语言。(Sun公司目前被Oracle公司(甲骨文公司)收购) 1996年发布JDK 1.0（第一个Java开发工具包）。 目前较常用的JDK版本：Java 8/JDK 1.8/JDK 8 Java三大块:  JavaSE（标准版） JavaEE（企业版） JavaME（微型版）   二、Java语言特性  简单性 相对而言是简单的，不在支持多继承(C++)，屏蔽了指针的概念。 面向对象 三大特点： 封装、继承、多态 可移植性（跨平台） Java程序可在Windows/Linux/Unix等操作系统上运行。\n原理：Java程序运行在虚拟的计算机上，简称JVM。 多线程\n 健壮性 自动垃圾回收机制，简称GC机制。\n 安全性 Java底层是C++实现的，不是C语言。\n  三、Java程序的加载与执行  xxx.java —— Java源文件 检查源代码是否符合Java语法 —— 编译过程 生成正常的字节码文件 xxx.class  字节码文件不是纯粹的二进制文件 JDK中的javac.exe是Java编译工具/命令  编译完成后，可以将xxx.class文件拷贝到其他操作系统中运行（跨平台）  JDK中除了javac.exe，还有一个java.exe是运行工具/命令  在DOS窗口中运行，例如运行A.class，输入java A运行。  java [类名] (java x.class // 是错误的写法) java.exe 命令会启动Java虚拟机(JVM)、JVM启动类加载器classLoader 找到类文件、装载到JVM中，解释成二进制数据 在系统中执行二进制与底层交互   四、注释的作用 注释：对源代码的解释说明，不会被编译到字节码(class)文件中，提高代码可读性。\n 单行注释 // \u0026hellip;\n 多行注释 /* \u0026hellip; */ Javadoc注释\n/**\n*\n*/\n比较专业的注释，可以通过javadoc.exe工具解析提取并生成帮助文档  五、JDK/JRE/JVM 的关系  JDK —— 开发过程中所需环境 JRE —— Java运行环境 JVM —— Java程序运行的虚拟机\n  Java程序开发 一、Java开发环境配置  安装JDK。常用版本JDK 8、最新JDK 11(LTS)  Oracle官方下载  环境变量PATH配置  编辑path，新增路径、指向JDK安装目录的bin文件夹下 （可选）新增classpath，指定一个路径，使JVM类加载器到该路径下加载类文件。默认从当前目录下加载。 在DOS窗口中输入javac -version检测安装成功   二、第一个Hello World程序  程序入口\npublic static void main(String[] args){ // 主方法 }  向控制台输出消息\nSystem.out.println(\u0026quot;Hello World\u0026quot;);  类体 方法体\n Java语句必须以“;”结束\n   public class 和 class的区别\n 1个Java源文件中可以定义多个class public的class不是必须的 每个class会对应生成一个x.class文件 定义公开类时，一个源文件中只能有一个public classs，且该类名必须和文件名称一致 每个class中都可以设定程序入口(main方法) 要执行x.class时要求x类中必须有主方法   三、Java语言基础  标识符  命名规则（不按照规则，编译会报错）  只能由“数字、字母、下划线、$”组成 不能以数字开头 严格区分大小写 不能使用关键字(public、static、void\u0026hellip;)  命名规范（不属于语法，个人习惯）  最好是见名知意 遵守驼峰命名方式(UserName) 类名、接口名：首字母大写、需驼峰式 变量名、方法名：首字母小写、后续单词的首字母大写 常量名：全部大写   数据类型\n 整数型\nint/short/long/byte 浮点型\nfloat/double 布尔型\nboolean 字符型\nchar 字符串（引用数据类型）             byte 字节型 1字节 -128~127   short 短整型 2字节 -32768~32767   int 整型 4字节 -2147483648~2147483647   long 长整型 8字节    boolean 布尔型 1字节 true/false   char 字符型 2字节 0~65535   float 单精度浮点型 4字节    double 双精度浮点型 8字节     容量从小到大排序： \u0026nbsp; byte \u0026lt; short / char \u0026lt; int \u0026lt; int \u0026lt; long \u0026lt; float \u0026lt; doouble\n 类型转换\n 在Java中、所有整数型的字面值都默认当做int类型处理，所有浮点型字面值都默认当做double类型处理。 当一个整数字面值没有超过数据类型的取值范围时、这个值可直接赋值给该变量\nshort s = 32768; // shot取值范围-32768~32767，所以报错：Type mismatch  char、byte、short 混合运算时，各自先转成int类型再做运算\n 多种数据类型的混合运算，先转换成容量最大的类型，再做运算\n   强制类型转换原理 long转int\n 原始数据 L100， 二进制表示：\n00000000 00000000 00000000 00000000 00000000 0000000 00000000 01100100\n 强转过程，将前四位二进制去掉，得到：\n00000000 0000000 00000000 01100100\n  强制转换时，可能损失一定的精度\n  四、Java开发  键盘扫描器对象\njava.util.Scanner scanner = java.util.Scanner(System.in); // 开始接受用户键盘输入 // 1.接收文本，以字符串的形式 String conten = scanner.next(); // 2.接收数字，以整数型的形式。如果不是数字、则程序报错。 Int num = scanner.nextInt();  垃圾回收 GC 方法\n// 建议JVM调度GC尽快回收 System.gc(); // JVM运行时的对象 Runtime rt = Runtime.getRuntime(); // 1.获取最大内存 rt.MaxMemory(); // 2.获取初始内存 rt.TotalMemory(); // 3.获取空闲内存 rt.FreeMemory();  抽象类\n 抽象类不可以实例化 抽象类中不一定必须有抽象方法，作用就是让该类不可实例化   abstract 和 final 的区别\na.抽象类：\n\u0026nbsp;\u0026nbsp;天生就用来被继承，通过子类来实现抽象方法，不继承就没有意义。\nb.final修饰类：\n\u0026nbsp;\u0026nbsp;专门用来禁止被继承。和抽象类刚好相反。\nc.所以 abstract 和 final不能同时修饰一个类。\n接口的定义\n 接口是一个标准，是一组抽象方法定义的结合，但所有的方法都没有实现。 接口可以看作只包含抽象方法的抽象类。 接口天生只能用来被继承，无法实例化。 定义方法： [返回值类型] 方法名称([参数]);\n在返回值类型，编译器会自动加上[public abstract]   飞机大战小游戏 练习笔记 Java图形界面 java.swing\n JFrame 是GUI程序的基础，它是屏幕上的windows的对象，能够最大化/最小化/关闭。\nJFame frame = new JFrame(\u0026quot;程序名\u0026quot;); // 设置窗口大小 frame.setSize(width, height); // 设置窗口置顶 frame.setAlwaysOnTop(true); // 设置窗口初始位置 null表居中 frame.setLocationRelative(null)：  JPanel 是面板容器类，可以加入到JFrame窗体中。\nJPanel panel = new JPanel(); // 设置背景 panel.setBackground(color); // 设置字体 panel.setFont(Font); // 重写Paint方法 绘制界面 @override public void paint(Graphics g) { // 画图片 g.drawImage(image, x, y, null); // 写字 g.drawString(str, x, y); } // 将画板加到Frame窗体中 frame.add(panel); // JFrame窗口默认不可见，需手动显示 frame.setVisible(true);  鼠标响应事件类 MouseAdapter\nMouseAdapter l = new MouseAdapter(){ // 重写需要响应的事件（点击、移动、移出/入） } // 添加监听器 // 支持鼠标移动监听 addMouseMotionListener(l); // 支持鼠标单击监听 addMouseListener(l);  定时器类\nTimer timer = new Timer(); // 定时器任务类 需要重写run方法执行的任务 TimerTask task = new TimerTask(){ @override public void run(){ // do something } } // a.定时器隔多久后执行一次任务 timer.schedule(task, delay); // b.定时器在指定时间执行 timer.schedule(task, Date); // c.循环执行，每隔多久执行 timer.schedule(task, delay, period);  数组扩容/压缩的方法\nInt[] arr1 = new Int[2]; // 方法一： // 1.定义新数组，长度为需扩容的大小 Int[] arr2 = new Int[4]; // 2.遍历旧数组，拷贝每一项 for(...); // 方法二： Intp[] arr2 = java.util.Arrays.copyof(原数组, 新长度); // 方法三 Int[] arr2 = new Int[4]; System.arraycopy(原数组, 起始下标, 新数组, 起始下标, 复制长度);   ","id":1,"section":"posts","summary":"\u003cp\u003e今年年初的时候，从C#转到Java开发，跟着大佬做了半年的业务开发，但是对于基础掌握的太少、所以自学了一些基础知识。\u003c/p\u003e","tags":["Java"],"title":"Java 入门基础知识点整理","uri":"https://allen-yangjh.github.io/2019/12/blog03/","year":"2019"},{"content":"localStorage、sessionStorage、Cookie的用法及区别。\nwebstorage webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage。\n1. localStorage 方法存储的数据没有时间限制。\n第二天、第二周或下一年之后，数据依然可用。\n2. sessionStorage 方法针对一个 session 进行数据存储。\n当用户关闭浏览器窗口后，数据会被删除。\n 键值对总是以字符串的形式存储\nlocalStorage和sessionStorage使用时使用相同的API：\n 存储数据：\nsessionStorage.setItem('key', 'str'); localStorage.setItem('key', 'str');  获取数据：\nsessionStorage.getItem('key'); localStorage.getItem('key');  删除某个数据：\nsessionStorage.removeItem('key'); localStorage.removeItem('key');  删除所有数据：\nsessionStorage.clear(); localStorage.clear();   localStorage 与 sessionStorage的比较  作用域不同  不同的浏览器无法共享localStorage或sessionStorage中的信息。 相同浏览器的不同页面之间（页面属于相同域名和端口）可以共享相同的 localStorage，但是不同页面或标签页间无法共享 sessionStorage 的信息。   3. Cookie 生命期为在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。\n存放数据大小为4K左右。有个数限制（各浏览器不同），一般不能超过20个。\n与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题。\n cookie的优点：具有极高的扩展性和可用性\n 通过良好的编程，控制保存在cookie中的session对象的大小。 通过加密和安全传输技术，减少cookie被破解的可能性。 只有在cookie中存放不敏感的数据，即使被盗取也不会有很大的损失。 控制cookie的生命期，使之不会永远有效。这样的话偷盗者很可能拿到的就 是一个过期的cookie。  cookie的缺点：\n cookie的长度和数量的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB。否则会被截掉。 安全性问题。如果cookie被人拦掉了，那个人就可以获取到所有session信息。加密的话也不起什么作用。 有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务端保存一个计数器。若吧计数器保存在客户端，则起不到什么作用。   localStorage、sessionStorage、Cookie共同点：都是保存在浏览器端，且同源的。","id":2,"section":"posts","summary":"\u003cp\u003elocalStorage、sessionStorage、Cookie的用法及区别。\u003c/p\u003e","tags":["JavaScript"],"title":"HTML 5 Web 本地存储","uri":"https://allen-yangjh.github.io/2019/12/blog02/","year":"2019"},{"content":"主要用于记录自己在项目工作和平时学习的过程中所碰到的Bug或疑难问题，方便回过头来查看复习。\n不断更新\u0026hellip;\n 微信ios/Safari中的new Date()格式化坑\nvar startTime = new Date('2017-03-08 00:00:00'); // 在ios中不兼容 返回valid Date // 将日其中的 - 替换成 /，兼容ios和Android var startTime2 = new Date('2017/03/08 00:00:00');  JQuery中Dom元素的data()用法\n 附加数据：\n// 附加单个数据 $(selector).data(key, value); // 附加多个数据 $(selector).data({key1: value, key2: value});  取回数据：\n// 取出指定数据 $(selector).data(key); // val // 取出所有数据 $(selector).data(); // obj  移除数据：\n// 移除指定数据 $(selector).removeData(key); // 移除多个数据 $(selector).removeData([key1, key2]);   JQuery中 attr() 与 prop() 的区别\nattr 与 prop 从中文意思看，两者分别是获取/设置 attributes 和 properties 的方法。\n什么时候使用attr()，什么时候使用prop()？\n官方的建议：具有 true 和 false 两个属性的属性，如 checked, selected 或者 disabled 时使用 prop()，其他的使用 attr()。\n CSS Position详解：\n position: static\n是默认布局，设置top、left属性不会有作用。 position: relative\n不会脱离文档流；\n相对于自己在文档流中的初始位置偏移定位。 position: fixed\n会脱离文档流；\n相对于浏览器窗口定位。 position: absolute\n会脱离文档流。\n是相对于父级 非position:static 浏览器定位。\n如果没有任何一个父级元素是 非position:static 属性，则会相对于文档定位。\n这里它的父级元素是包含爷爷级元素、祖爷爷级元素、祖宗十八代级元素的。任意一级都可以。\n如果它的父级元素和爷爷级元素都是非position:static 属性，则，它会选择距离最近的父元素。  IDEA中 subversion 的使用说明\n参考：https://blog.csdn.net/qq_27093465/article/details/74898489\n JS中 substr() 和 substring() 的区别\n\tstring.substring(from, to); // from：指要截取的子串第一个字符在原字符串中的位置 // to：指所要截取的子字符串最后一个字符的后一位（如果省略则默认截到最后一位） string.substr(start, length); // start：指截取子串开始下标 // length：指截取子串的长度（如果省略则默认截到最后一位）  JS中 if 条件为 null/undefined/NaN/0/\u0026ldquo;\u0026rdquo; 表达式时，均为false\n官方解释： Boolean 表达式\n一个值为 true 或者 false 的表达式。如果需要，非 Boolean 表达式也可以被转换为 Boolean 值，但是要遵循下列规则：\n 所有的对象都被当作 true。 当且仅当字符串为空时，该字符串被当作 false。 null 和 undefined 被当作 false。 当且仅当数字为零时，该数字被当作 false。  JQ中 children() 和 find() 方法的区别：\n children() 只获取匹配当前元素的下一级元素； find() 可获取匹配当前元素的整个树级元素；  Windows下查看IIS中站点对应的进程PID，以用来方便进程调试\n 管理员身份运行cmd，跳转到C:\\Windows\\System32\\inetsrv目录，然后运行appcmd list wp即可查看  Aspose实现Office转PDF (ASP.NET)\n参考 https://www.cnblogs.com/moonache/p/4991459.html\n其他方法Microsoft.Office https://www.cnblogs.com/yunfeifei/p/4520414.html\n C#中 webservice 请求响应时间设置\n a.服务端webconfig中\n\u0026lt; httpRuntime executionTimeout=\u0026ldquo;300\u0026rdquo; /\u0026gt; \u0026lt; compilation debug=\u0026ldquo;false\u0026rdquo; /\u0026gt; b.客户端调用时 加上\nHttpWebRequest wr = (HttpWebRequest)base.GetWebRequest( uri ); wr.Timeout = 300*1000;  参考： https://blog.csdn.net/wygyhm/article/details/2819388\n ","id":3,"section":"posts","summary":"\u003cp\u003e主要用于记录自己在项目工作和平时学习的过程中所碰到的Bug或疑难问题，方便回过头来查看复习。\u003cbr /\u003e\n\u003cem\u003e不断更新\u0026hellip;\u003c/em\u003e\u003c/p\u003e","tags":["JavaScript","CSS","C#"],"title":"随笔01","uri":"https://allen-yangjh.github.io/2019/12/essay01/","year":"2019"},{"content":"结合实际例子与使用方式介绍Array对象的方法。\nJS中 Array 对象的方法使用详解: 1.常用的基本方法  concat() (合并数组)连接两个或个多的数组，并返回结果。传入的可以是具体值、也可以是数组对象。 该方法不改变原数组\nlet arr1 = [1, 2, 3]; let arr2 = [4, 5]; arr1.concat(arr2, 6); // [1, 2, 3, 4, 5, 6]  join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔，如果省略该参数，则默认使用逗号作为分隔符。\nlet arr = [1, 2, 3]; arr.join('|'); // \u0026quot;1|2|3\u0026quot;  pop() 删除并返回数组的最后一个元素，把数组长度减 1。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。\nlet arr = [1, 2, 3]; arr.pop(); // 3  push() 向数组的末尾添加一个或多个元素，返回新的长度。\npush() 方法和 pop() 方法使用数组提供的先进后出栈的功能。\nlet arr = [\u0026quot;Bob\u0026quot;, \u0026quot;John\u0026quot;]; arr.push(\u0026quot;James\u0026quot;); // 3 console.log(arr); // [\u0026quot;Bob\u0026quot;, \u0026quot;John\u0026quot;, \u0026quot;James\u0026quot;]  shift() 删除并返回数组的第一个元素。将已经存在的元素顺次往前移。\nlet arr = [1, 2, 3]; arr.shift(); // 1  unshift() 向数组的开头添加一个或多个元素，返回新的长度。将参数插入数组的头部，将已经存在的元素顺次往后移。\nunshift() 方法无法在 Internet Explorer 中正确地工作！\nlet arr = [\u0026quot;Bob\u0026quot;, \u0026quot;John\u0026quot;]; arr.unshift(\u0026quot;James\u0026quot;); // 3 console.log(arr); // [\u0026quot;James\u0026quot;, \u0026quot;Bob\u0026quot;, \u0026quot;John\u0026quot;]  reverse() 颠倒数组中元素的顺序。\n不常用\n slice() (裁剪数组)根据下标返回数组中选定的元素。包含start和end两个参数，可以为负数(从数组尾部开始算起)。如果 end 未被规定，会选取从 start 到数组结尾的所有元素。\nlet arr = [\u0026quot;George\u0026quot;, \u0026quot;John\u0026quot;, \u0026quot;Thomas\u0026quot;, \u0026quot;James\u0026quot;, \u0026quot;Adrew\u0026quot;]; arr.slice(2); // [\u0026quot;Thomas\u0026quot;, \u0026quot;James\u0026quot;, \u0026quot;Adrew\u0026quot;] arr.slice(2, 4); // [\u0026quot;Thomas\u0026quot;, \u0026quot;James\u0026quot;]  splice() (拼接数组)向数组指定位置删除或添加元素，返回被删除项目的新数组。删除的元素个数可以跟替换的元素个数不相等。\nlet arr = [\u0026quot;Bob\u0026quot;, \u0026quot;John\u0026quot;, \u0026quot;James\u0026quot;]; // 1.添加1个元素 arr.splice(1, 0, \u0026quot;William\u0026quot;); // [] 如果没有删除元素则返回空 console.log(arr); // [\u0026quot;Bob\u0026quot;, \u0026quot;William\u0026quot;, \u0026quot;John\u0026quot;, \u0026quot;James\u0026quot;] // 2.删除1个元素 arr = [\u0026quot;Bob\u0026quot;, \u0026quot;John\u0026quot;, \u0026quot;James\u0026quot;]; arr.splice(1, 1); // [\u0026quot;John\u0026quot;] console.log(arr); // [\u0026quot;Bob\u0026quot;, \u0026quot;James\u0026quot;] // 3.删除2个元素 添加1个元素来替换 arr = [\u0026quot;Bob\u0026quot;, \u0026quot;John\u0026quot;, \u0026quot;James\u0026quot;]; arr.splice(1, 2, \u0026quot;William\u0026quot;); // [\u0026quot;John\u0026quot;, \u0026quot;James\u0026quot;] console.log(arr); // [\u0026quot;Bob\u0026quot;, \u0026quot;William\u0026quot;]  sort() 对数组的元素进行排序。传入的必须是函数，如果没有传入参数，将按照内置算法对元素进行排序。 该方法在原数组上进行排序\n[内置算法]: JS中sort实现的算法是O(n^2)的冒泡排序，并会将每一项通过toString()转型，即将每一项转化为ASCII进行比较。\n如果想按照其他标准进行排序，就需要提供比较函数，该函数应该具有两个参数 a 和 b，其返回值如下：\n  若 a 小于 b，则返回一个小于0的值。在排序后的数组中 a 将出现在 b 之前 若 a 等于 b，则返回0。 若 a 大于 b，则返回一个大于0的值。\n   let arr = [10, 5, 40, 25, 100, 1]; // 内置算法会将数组中的每一项转化为ASCII进行比较，所以排序顺序有误。 arr.sort(); // [1, 10, 25, 40, 5] // 常见的比较函数有： // 1.按照数值大小升序排序 arr.sort(function(a,b){ return a - b; })； // [1, 5, 10, 25, 40, 100] // 2.按照数值大小降序排序 arr.sort(function(a,b){ return b - a; }); // [100, 40, 25, 10, 5, 1] // 3.按照对象的某一属性值排序 arr = [ {name: \u0026quot;Bob\u0026quot;, age: 13}, {name: \u0026quot;John\u0026quot;, age: 22}, {name: \u0026quot;James\u0026quot;, age: 7} ]; arr.sort(function(a, b){ var value1 = a.age; var value2 = b.age; return value1 - value2; }); // 4.打乱数组 arr.sort(function(a,b){ return Math.random() - 0.5; })  toString() 把数组转换为(逗号分隔的)字符串。返回值与没有参数的 join() 方法返回的字符串相同。\nlet arr = [1, 2, 3]; arr.toString(); // \u0026quot;1, 2, 3\u0026quot;   2.迭代方法  every() 用于检测数组所有元素是否都符合某个指定函数的条件。 该方法不改变原始数组\n若使用空数组，此方法在一切情况下都返回 true。\n every() 方法使用指定函数检测数组中的所有元素：\n 该函数接收3个参数，当前值_currentVal(必须)，当前值索引_index(可选)，当前数组_array(可选)。 如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。 如果所有元素都满足条件，则返回 true。   // 检测数组所有元素是否都大于10 function compare(val){ return val \u0026gt; 10; } let arr1 = [1, 11, 2, 22]; let arr2 = [20, 30, 40, 50]; arr1.every(compare); // false arr2.every(compare); // true  some() 用于检测数组所有元素是否至少有1项符合某个指定函数的条件。 该方法不改变原始数组\n若使用空数组，此方法在一切情况下都返回 false。\n some() 方法使用指定函数检测数组中的所有元素：\n 该函数接收3个参数，当前值_currentVal(必须)，当前值索引_index(可选)，当前数组_array(可选)。 如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。 如果没有满足条件的元素，则返回false。   // 检测数组是否有元素大于10 function compare(val){ return val \u0026gt; 10; } let arr1 = [1, 11, 2, 22]; let arr2 = [2, 3, 4, 5]; arr1.some(compare); // true arr2.some(compare); // false  filter() (过滤)用于找出数组中所有符合某个指定函数条件的元素、组成新的数组，并返回过滤后的新数组。 该方法不改变原始数组\n filter() 方法循环数组中的所有元素调用指定函数进行过滤：\n 该函数接收3个参数，当前值_currentVal(必须)，当前值索引_index(可选)，当前数组_array(可选)。\n 如果没有任何满足条件的元素，则返回空数组。   // 找出大于10的元素 function compare(val){ return val \u0026gt; 10; } let arr1 = [1, 11, 2, 22]; let arr2 = [2, 3, 4, 5]; arr1.filter(compare); // [11, 22] arr2.filter(compare); // []  forEach() (循环)用于对数组中的每个元素调用一次某个指定函数，没有返回值。\n除了抛出异常以外，没有办法中止或跳出 forEach() 循环。\n forEach() 方法接收一个指定函数：\n 该函数接收3个参数，当前值_currentVal(必须)，当前值索引_index(可选)，当前数组_array(可选)。\n   let arr = [1, 2, 3]; arr.forEach(function(item, index, arr){ arr[index] = val + 1; }); console.log(arr); // [2, 3, 4]  map() 将数组中的每一项调用某个指定函数后返回的结果组成新的数组，并返回该数组。 该方法不改变原始数组\n map() 方法接收一个指定函数：\n 该函数接收3个参数，当前值_currentVal(必须)，当前值索引_index(可选)，当前数组_array(可选)。   // 将数组中每一项乘以2 let arr = [1, 2 ,3]; arr.map(function(item){ return item * 2; }); console.log(arr); // [2, 4, 6]  reduce() 将数组中的每个元素调用某个指定的reducer函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。 该方法不改变原始数组\n reduce() 方法接收1个reducer函数和1个initialValue_初始值:\n reducer函数接收4个参数，累计器_accumulator(必须)，当前值_currentVal(必须)，当前值索引_index(可选)，当前数组_array(可选)。 如果没有提供初始值，则起始索引号为1，否则从索引0起始。 如果数组为空且没有提供初始值，调用reduce将报错。   // 累加方法 function add(prev, cur){ return prev + cur; }; // 未传入初始值 [0, 1, 2, 3, 4].reduce(add); // 10 // 传入初始值 [0, 1, 2, 3, 4].reduce(add, 5); // 15 // 注意点： // 1.如果数组仅有一个元素（无论位置如何）并且没有提供初始值，那么此唯一值将被返回并且callback不会被执行。 [ , 10].reduce(add); // 10 // 2.如果有提供初始值但是数组为空，那么此唯一值将被返回并且callback不会被执行。 [].reduce(add, 11); // 11 // 3.如果数组为空且没有提供初始值，会抛出TypeError 。 [].reduce(add); // TypeError // 例子：计算数组中每个元素出现的次数 var names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice']; var countedNames = names.reduce(function (allNames, name) { if (name in allNames) { allNames[name]++; } else { allNames[name] = 1; } return allNames; }, {}); console.log(countedNames); // { 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 }  reduceRight() 该方法的功能和 reduce() 功能是一样的，不同的是 reduceRight() 从数组的末尾向前循环每一项。\n//reduce 与 reduceRight 之间的区别 function add(prev, cur) { return prev + cur; } let arr = ['1', '2', '3', '4', '5']; let left = arr.reduce(add); let right = arr.reduceRight(add); console.log(left); // \u0026quot;12345\u0026quot; console.log(right); // \u0026quot;54321\u0026quot;   参考资料：  https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array https://www.runoob.com/jsref/jsref-obj-array.html ","id":4,"section":"posts","summary":"\u003cp\u003e结合实际例子与使用方式介绍Array对象的方法。\u003c/p\u003e","tags":["JavaScript"],"title":"JavaScript Array 对象","uri":"https://allen-yangjh.github.io/2019/12/blog01/","year":"2019"}],"tags":[{"title":"C#","uri":"https://allen-yangjh.github.io/tags/c#/"},{"title":"CSS","uri":"https://allen-yangjh.github.io/tags/css/"},{"title":"Java","uri":"https://allen-yangjh.github.io/tags/java/"},{"title":"JavaScript","uri":"https://allen-yangjh.github.io/tags/javascript/"}]}